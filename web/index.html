<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Magazzino Filamenti &amp; Stima</title>
  <style>
    :root{
      --bg:#0f172a;
      --card:#1e293b;
      --muted:#94a3b8;
      --text:#e2e8f0;
      --ring:#334155;
      --accent:#38bdf8;
      --error:#f87171;
      --ok:#34d399;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue","Noto Sans",sans-serif}
    a{color:var(--accent)}
    .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:18px}
    @media (max-width:1000px){.grid{grid-template-columns:1fr}}
    .card{background:var(--card);border-radius:16px;padding:18px;border:1px solid var(--ring)}
    h1{margin:0 0 12px;font-size:28px}
    h2{margin:0 0 12px;font-size:20px}
    h3{margin:18px 0 12px;font-size:16px;color:var(--muted)}
    .palette{display:flex;flex-direction:column;gap:10px;max-height:520px;overflow:auto;padding-right:6px}
    .pill{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px 14px;border-radius:16px;background:#0b1527;border:1px solid var(--ring);cursor:pointer;transition:transform .15s ease, border-color .2s}
    .pill:hover{transform:translateY(-2px);border-color:var(--accent)}
    .pill[aria-selected="true"]{outline:2px solid var(--accent)}
    .left{display:flex;align-items:center;gap:12px}
    .dot{width:18px;height:18px;border-radius:50%;border:1px solid rgba(255,255,255,.25)}
    .dot.transparent{
      background-image:
        linear-gradient(45deg,#999 25%,transparent 25%),
        linear-gradient(-45deg,#999 25%,transparent 25%),
        linear-gradient(45deg,transparent 75%,#999 75%),
        linear-gradient(-45deg,transparent 75%,#999 75%);
      background-size:8px 8px;
      background-position:0 0,0 4px,4px -4px,-4px 0;
      background-color:#fff;
    }
    .title{font-weight:700}
    .sub{font-size:12px;color:var(--muted)}
    .price{font-weight:800}
    .row{display:flex;gap:12px;align-items:center}
    .row.wrap{flex-wrap:wrap}
    input[type="file"],input[type="text"],input[type="number"],button{border-radius:10px;border:1px solid var(--ring);background:#0b1527;color:var(--text);padding:10px 12px;font-size:14px}
    input[type="number"]{width:100%}
    button{cursor:pointer;transition:background .2s}
    button:hover{background:#13213a}
    .hint{color:var(--muted);font-size:13px}
    .viewer{position:relative;height:520px;border-radius:16px;border:1px dashed var(--ring);background:#0b1527;overflow:hidden}
    .viewer.drag{border-color:var(--accent)}
    canvas.viewer-canvas{position:absolute;inset:0;width:100%;height:100%}
    .viewer-overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;text-align:center;padding:20px;color:var(--muted);transition:opacity .3s ease;pointer-events:none}
    .viewer-overlay[data-tone="error"]{color:var(--error)}
    .viewer-overlay.hidden{opacity:0}
    .stats-grid,.info-grid,.params-grid,.result-grid{display:grid;gap:12px}
    .stats-grid{grid-template-columns:repeat(auto-fit,minmax(160px,1fr));margin-top:12px}
    .info-grid{grid-template-columns:repeat(auto-fit,minmax(140px,1fr));margin:12px 0}
    .params-grid{grid-template-columns:repeat(auto-fit,minmax(160px,1fr));margin:12px 0 4px}
    .result-grid{grid-template-columns:repeat(auto-fit,minmax(180px,1fr));margin-top:12px}
    .stat,.param,.result{background:#0b1527;border:1px solid var(--ring);border-radius:12px;padding:12px}
    .stat-title,.result-title{font-size:12px;text-transform:uppercase;letter-spacing:.04em;color:var(--muted);margin-bottom:6px}
    .stat-value,.result-value{font-size:18px;font-weight:700}
    .result-sub{font-size:12px;color:var(--muted);margin-top:4px}
    label.param{display:flex;flex-direction:column;gap:6px;font-size:13px;color:var(--muted)}
    .error-text{color:var(--error);font-weight:600}
    .success-text{color:var(--ok);font-weight:600}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Magazzino Filamenti &amp; Stima</h1>
    <p class="hint">Dati e prezzi da Spoolman (€/kg). Costo macchina fisso lato server. Carica un modello per ottenere anteprima 3D, analisi geometrica e stima di consumo, tempo e prezzo.</p>

    <div class="grid">
      <div class="card">
        <h2>Palette (seleziona materiale)</h2>
        <div id="palette" class="palette" role="listbox" aria-label="Seleziona materiale e colore per la stima"></div>
        <p class="hint">Ogni voce mostra: <b>Materiale</b> — <span class="sub">Nome colore (HEX)</span> — <b>€/kg</b>.</p>
      </div>

      <div class="card">
        <h2>Viewer 3D &amp; dettagli modello</h2>
        <div id="viewer" class="viewer" aria-live="polite">
          <div id="viewerOverlay" class="viewer-overlay">Trascina qui un file STL/OBJ/3MF o utilizza i pulsanti sotto per caricare/recuperare un modello.</div>
        </div>
        <div id="modelStats" class="stats"></div>
      </div>
    </div>

    <div class="card" style="margin-top:18px">
      <h2>Stima tempi &amp; costi</h2>
      <div class="row wrap">
        <input id="file" type="file" accept=".stl,.obj,.3mf,.zip" />
        <button id="btnUpload">Carica</button>
        <input id="url" type="text" placeholder="https://www.printables.com/model/..." style="flex:1;min-width:260px" />
        <button id="btnFetch">Carica da URL</button>
      </div>
      <p class="hint">Dopo il caricamento scegli un materiale dalla palette; il prezzo €/kg arriva dalle <b>bobine</b>. L'elenco si aggiorna ogni 60 s.</p>

      <h3>Parametri di stampa (stimati)</h3>
      <div class="params-grid">
        <label class="param">Diametro filamento (mm)
          <input id="filamentDiameter" type="number" step="0.01" min="1" value="1.75" />
        </label>
        <label class="param">Diametro ugello (mm)
          <input id="nozzle" type="number" step="0.01" min="0.1" value="0.4" />
        </label>
        <label class="param">Altezza layer (mm)
          <input id="layerHeight" type="number" step="0.01" min="0.05" value="0.2" />
        </label>
        <label class="param">Spessore guscio (mm)
          <input id="shellThickness" type="number" step="0.1" min="0" value="1.2" />
        </label>
        <label class="param">Infill (%)
          <input id="infill" type="number" step="1" min="0" max="100" value="15" />
        </label>
        <label class="param">Velocità media (mm/s)
          <input id="printSpeed" type="number" step="1" min="1" value="60" />
        </label>
        <label class="param">Fattore extra tempo
          <input id="timeMultiplier" type="number" step="0.05" min="1" value="1.2" />
        </label>
      </div>
      <p class="hint">Modifica questi parametri per adeguare la stima a profili di stampa diversi (guscio = pareti/perimetri equivalenti).</p>

      <div id="spoolInfo" class="info"></div>
      <div id="estimateResults" class="result-grid"></div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { STLLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/STLLoader.js';
    import { OBJLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/OBJLoader.js';
    import { ThreeMFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/3MFLoader.js';

    // ---------- util colore accessibile ----------
    function hexToRgb(hex){
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex||'');
      return m ? {r:parseInt(m[1],16), g:parseInt(m[2],16), b:parseInt(m[3],16)} : {r:127,g:127,b:127};
    }
    const BASIC = {
      '#000000':'Nero', '#FFFFFF':'Bianco', '#FF0000':'Rosso', '#00FF00':'Verde',
      '#0000FF':'Blu', '#FFFF00':'Giallo', '#FFA500':'Arancione', '#FFC0CB':'Rosa',
      '#800080':'Viola', '#A52A2A':'Marrone', '#808080':'Grigio', '#00FFFF':'Ciano',
      '#008000':'Verde scuro', '#ADD8E6':'Azzurro', '#FFD700':'Oro', '#8B4513':'Terra di Siena'
    };
    function nearestBasicName(hex){
      const {r,g,b}=hexToRgb(hex), entries=Object.entries(BASIC);
      let best=entries[0][0], dist=1e9;
      for(const [h] of entries){
        const c=hexToRgb(h); const d=(r-c.r)**2+(g-c.g)**2+(b-c.b)**2;
        if(d<dist){dist=d;best=h}
      }
      return BASIC[best];
    }

    const viewerEl = document.getElementById('viewer');
    const overlayEl = document.getElementById('viewerOverlay');
    const statsBox = document.getElementById('modelStats');
    const spoolInfoBox = document.getElementById('spoolInfo');
    const estimateBox = document.getElementById('estimateResults');

    let selectedKey = null;
    let inventoryItems = [];
    let hourlyRate = null;
    let currency = 'EUR';
    let currentAnalysis = null;
    let currentModelUrl = null;
    let currentFilename = null;

    const REFRESH_MS = 60000; // 60 s

    const densityLookups = [
      {test:/pla\s*\+?/i, value:1.24},
      {test:/petg|pctg/i, value:1.27},
      {test:/asa/i, value:1.07},
      {test:/abs/i, value:1.04},
      {test:/tpu|flex|ninjar/i, value:1.20},
      {test:/pa|nylon/i, value:1.14},
      {test:/pc/i, value:1.20},
      {test:/peek/i, value:1.31},
      {test:/cf|carbon/i, value:1.35},
      {test:/hips/i, value:1.04},
      {test:/pp/i, value:0.90}
    ];
    function densityForMaterial(material){
      if(!material) return 1.24;
      for(const entry of densityLookups){
        if(entry.test.test(material)) return entry.value;
      }
      return 1.24;
    }

    function showOverlay(text, tone='info'){
      overlayEl.textContent = text;
      overlayEl.dataset.tone = tone;
      overlayEl.classList.remove('hidden');
    }
    function hideOverlay(){
      overlayEl.classList.add('hidden');
    }

    // ---------- THREE.js viewer ----------
    let renderer = null;
    let scene = null;
    let camera = null;
    let controls = null;
    let currentObject = null;

    const stlLoader = new STLLoader();
    const objLoader = new OBJLoader();
    const threeMFLoader = new ThreeMFLoader();

    function ensureViewer(){
      if(renderer) return;
      renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(viewerEl.clientWidth, viewerEl.clientHeight);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.domElement.classList.add('viewer-canvas');
      viewerEl.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      scene.background = new THREE.Color('#0b1527');

      camera = new THREE.PerspectiveCamera(45, viewerEl.clientWidth / viewerEl.clientHeight, 0.1, 10000);
      camera.position.set(200, 200, 200);

      const hemi = new THREE.HemisphereLight(0xffffff, 0x202020, 1.0);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(100, 200, 100);
      scene.add(dir);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.target.set(0,0,0);

      const grid = new THREE.GridHelper(400, 20, 0x3b82f6, 0x1e3a8a);
      grid.position.y = -0.001;
      scene.add(grid);

      window.addEventListener('resize', onResize);
      animate();
    }

    function onResize(){
      if(!renderer || !camera) return;
      const {clientWidth, clientHeight} = viewerEl;
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(clientWidth, clientHeight);
    }

    function animate(){
      requestAnimationFrame(animate);
      if(controls) controls.update();
      if(renderer && scene && camera){
        renderer.render(scene, camera);
      }
    }

    function clearCurrentObject(){
      if(currentObject){
        scene.remove(currentObject);
        currentObject.traverse?.(child=>{
          if(child.isMesh){
            child.geometry?.dispose?.();
            child.material?.dispose?.();
          }
        });
      }
      currentObject = null;
    }

    async function loadModel(path){
      ensureViewer();
      showOverlay('Caricamento modello...');
      let object = null;
      const ext = (path.split('.').pop() || '').toLowerCase();
      try{
        if(ext === 'stl'){
          const geom = await stlLoader.loadAsync(path);
          geom.computeVertexNormals();
          object = new THREE.Mesh(geom, new THREE.MeshStandardMaterial({color:0x9fc5ff, metalness:0.05, roughness:0.8}));
        } else if(ext === 'obj'){
          object = await objLoader.loadAsync(path);
          object.traverse(child=>{
            if(child.isMesh){
              child.material = new THREE.MeshStandardMaterial({color:0x9fc5ff, metalness:0.05, roughness:0.8});
            }
          });
        } else if(ext === '3mf'){
          object = await threeMFLoader.loadAsync(path);
          object.traverse(child=>{
            if(child.isMesh){
              child.material = new THREE.MeshStandardMaterial({color:0x9fc5ff, metalness:0.05, roughness:0.8});
            }
          });
        } else {
          showOverlay('Formato non supportato per la preview. Usa STL, OBJ o 3MF.', 'error');
          return false;
        }
      } catch (err){
        console.error('Errore caricamento modello', err);
        showOverlay('Errore nel caricamento del modello per la preview.', 'error');
        return false;
      }

      const box = new THREE.Box3().setFromObject(object);
      const size = new THREE.Vector3();
      box.getSize(size);
      const center = new THREE.Vector3();
      box.getCenter(center);
      object.position.sub(center);

      clearCurrentObject();
      currentObject = object;
      scene.add(object);

      const maxDim = Math.max(size.x, size.y, size.z, 1);
      const radius = maxDim * 1.2;
      const fov = camera.fov * (Math.PI / 180);
      let distance = radius / Math.sin(fov / 2);
      distance = Math.max(distance, 5);
      camera.position.set(distance, distance, distance);
      controls.target.set(0, 0, 0);
      controls.update();

      hideOverlay();
      return true;
    }

    // ---------- palette ----------
    async function loadPalette(){
      try{
        const res = await fetch('/inventory?nocache='+Date.now());
        if(!res.ok) throw new Error('HTTP '+res.status);
        const data = await res.json();
        inventoryItems = data.items || [];
        hourlyRate = (typeof data.hourly_rate === 'number') ? data.hourly_rate : null;
        currency = data.currency || 'EUR';
        renderPalette(inventoryItems);
        renderSpoolInfo();
        updateEstimate();
      }catch(err){
        console.error('Impossibile caricare palette', err);
      }
    }

    function renderPalette(items){
      const box = document.getElementById('palette');
      box.innerHTML = '';
      if(selectedKey && !items.some(it=>it.key===selectedKey)){
        selectedKey = null;
      }
      if(!items.length){
        const empty = document.createElement('p');
        empty.className = 'hint';
        empty.textContent = 'Nessuna bobina disponibile (controlla Spoolman).';
        box.appendChild(empty);
        return;
      }
      items
        .sort((a,b)=> (a.material||'').localeCompare(b.material||'') || (a.color||'').localeCompare(b.color||''))
        .forEach(it=>{
          const hex = (it.color || '#777777').toUpperCase();
          const price = (it.price_per_kg!=null) ? `${it.price_per_kg.toFixed(2)} ${it.currency}/kg` : 'n/d';
          const colorName = it.color_name || nearestBasicName(hex);

          const row = document.createElement('div');
          row.className='pill';
          row.setAttribute('role','option');
          row.setAttribute('aria-label', `${it.material}, ${colorName}, ${price}`);
          row.setAttribute('aria-selected', selectedKey===it.key ? 'true' : 'false');
          row.onclick = ()=>{
            selectedKey = it.key;
            [...box.children].forEach(c=>c.setAttribute?.('aria-selected','false'));
            row.setAttribute('aria-selected','true');
            renderSpoolInfo();
            updateEstimate();
          };

          const left = document.createElement('div'); left.className='left';
          const dot = document.createElement('span'); dot.className='dot' + (it.is_transparent ? ' transparent' : '');
          if(!it.is_transparent){ dot.style.backgroundColor = hex; }
          dot.title = `${colorName} (${hex})`; dot.setAttribute('aria-hidden','true');

          const col = document.createElement('div');
          const t1 = document.createElement('div'); t1.className='title'; t1.textContent = it.material || 'n/d';
          const t2 = document.createElement('div'); t2.className='sub'; t2.textContent = `${colorName} (${hex})`;
          col.appendChild(t1); col.appendChild(t2);

          left.appendChild(dot); left.appendChild(col);
          const priceEl = document.createElement('div'); priceEl.className='price'; priceEl.textContent = price;

          row.appendChild(left); row.appendChild(priceEl);
          box.appendChild(row);
        });
    }

    function selectedSpool(){
      if(!selectedKey) return null;
      return inventoryItems.find(it=>it.key===selectedKey) || null;
    }

    function renderSpoolInfo(){
      const spool = selectedSpool();
      if(!spool){
        spoolInfoBox.innerHTML = '<p class="hint">Seleziona un materiale dalla palette per vedere densità stimata e costi.</p>';
        return;
      }
      const price = (spool.price_per_kg!=null) ? `${spool.price_per_kg.toFixed(2)} ${spool.currency}/kg` : 'n/d';
      const density = densityForMaterial(spool.material || '').toFixed(2);
      const remaining = spool.remaining_g!=null ? `${spool.remaining_g.toFixed(0)} g` : 'n/d';
      const count = spool.count!=null ? spool.count : 0;
      spoolInfoBox.innerHTML = `
        <div class="info-grid">
          <div class="stat"><div class="stat-title">Materiale</div><div class="stat-value">${spool.material || 'n/d'}</div></div>
          <div class="stat"><div class="stat-title">Prezzo</div><div class="stat-value">${price}</div></div>
          <div class="stat"><div class="stat-title">Densità stimata</div><div class="stat-value">${density} g/cm³</div></div>
          <div class="stat"><div class="stat-title">Bobine attive</div><div class="stat-value">${count}</div></div>
          <div class="stat"><div class="stat-title">Rimanenza stimata</div><div class="stat-value">${remaining}</div></div>
        </div>
      `;
    }

    // ---------- upload / fetch ----------
    async function uploadFileOrBlob(file){
      const fd = new FormData(); fd.append('file', file);
      showOverlay('Caricamento file...');
      try{
        const r = await fetch('/upload_model', {method:'POST', body: fd});
        if(!r.ok){
          const detail = await r.json().catch(()=>({detail:'Upload fallito'}));
          showOverlay(detail.detail || 'Upload fallito', 'error');
          return;
        }
        const j = await r.json();
        handleModelResponse(j);
      }catch(err){
        console.error('Upload fallito', err);
        showOverlay('Errore di rete durante l\'upload', 'error');
      }
    }

    async function uploadFile(){
      const f = document.getElementById('file').files[0];
      if(!f){ alert('Seleziona un file'); return; }
      uploadFileOrBlob(f);
    }

    async function fetchFromUrl(){
      const url = document.getElementById('url').value.trim();
      if(!url){ alert('Inserisci una URL'); return; }
      showOverlay('Recupero modello da URL...');
      try{
        const r = await fetch('/fetch_model', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({url})});
        const j = await r.json();
        if(!r.ok){
          showOverlay(j.detail || 'Download fallito', 'error');
          return;
        }
        handleModelResponse(j);
      }catch(err){
        console.error('Fetch fallito', err);
        showOverlay('Errore durante il download del modello', 'error');
      }
    }

    function handleModelResponse(data){
      currentModelUrl = data.viewer_url || null;
      currentFilename = data.filename || null;
      currentAnalysis = data.analysis || null;
      renderModelStats();
      updateEstimate();
      if(currentModelUrl){
        loadModel(currentModelUrl);
      }
    }

    // drag & drop
    viewerEl.addEventListener('dragover', e => { e.preventDefault(); viewerEl.classList.add('drag'); showOverlay('Rilascia il file per caricarlo'); });
    viewerEl.addEventListener('dragleave', () => { viewerEl.classList.remove('drag'); if(currentModelUrl) hideOverlay(); else showOverlay('Trascina qui un file STL/OBJ/3MF o utilizza i pulsanti sotto per caricare/recuperare un modello.'); });
    viewerEl.addEventListener('drop', e => {
      e.preventDefault(); viewerEl.classList.remove('drag');
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if(f){ uploadFileOrBlob(f); }
    });

    function renderModelStats(){
      if(!currentAnalysis){
        statsBox.innerHTML = '<p class="hint">Carica un modello per visualizzare dimensioni, volume e qualità della mesh.</p>';
        return;
      }
      if(currentAnalysis.error){
        statsBox.innerHTML = `<p class="error-text">${currentAnalysis.error}</p>`;
        return;
      }
      const dims = (currentAnalysis.bbox_mm || []).map(v=>Math.abs(v));
      const dimsText = dims.length ? `${dims.map(v=>v.toFixed(1)).join(' × ')} mm` : 'n/d';
      const volumeCm3 = currentAnalysis.volume_mm3 ? currentAnalysis.volume_mm3 / 1000 : 0;
      const areaCm2 = currentAnalysis.surface_area_mm2 ? currentAnalysis.surface_area_mm2 / 100 : 0;
      const watertight = currentAnalysis.is_watertight ? '<span class="success-text">Sì</span>' : '<span class="error-text">No</span>';
      const approx = currentAnalysis.approximate_volume ? '<span class="hint">(volume stimato tramite convessità)</span>' : '';
      const triangles = currentAnalysis.triangle_count || 0;

      statsBox.innerHTML = `
        <div class="stats-grid">
          <div class="stat"><div class="stat-title">Dimensioni</div><div class="stat-value">${dimsText}</div></div>
          <div class="stat"><div class="stat-title">Volume solido</div><div class="stat-value">${volumeCm3 ? volumeCm3.toFixed(2)+' cm³' : 'n/d'} ${approx}</div></div>
          <div class="stat"><div class="stat-title">Superficie</div><div class="stat-value">${areaCm2 ? areaCm2.toFixed(1)+' cm²' : 'n/d'}</div></div>
          <div class="stat"><div class="stat-title">Triangoli</div><div class="stat-value">${triangles.toLocaleString('it-IT')}</div></div>
          <div class="stat"><div class="stat-title">Mesh chiusa</div><div class="stat-value">${watertight}</div></div>
        </div>
        ${currentFilename ? `<p class="hint" style="margin-top:10px">File: <a href="${currentModelUrl}" target="_blank" rel="noreferrer">${currentFilename}</a></p>` : ''}
      `;
    }

    function getInputNumber(id, fallback){
      const el = document.getElementById(id);
      if(!el) return fallback;
      const v = parseFloat(el.value);
      return Number.isFinite(v) ? v : fallback;
    }

    function formatCurrency(value){
      if(!Number.isFinite(value)) return 'n/d';
      return new Intl.NumberFormat('it-IT', {style:'currency', currency: currency || 'EUR', minimumFractionDigits:2, maximumFractionDigits:2}).format(value);
    }

    function formatNumber(value, digits=2, suffix=''){
      if(!Number.isFinite(value)) return 'n/d';
      return `${value.toLocaleString('it-IT',{minimumFractionDigits:digits,maximumFractionDigits:digits})}${suffix}`;
    }

    function formatDuration(hours){
      if(!Number.isFinite(hours)) return 'n/d';
      const totalMinutes = Math.round(hours * 60);
      const h = Math.floor(totalMinutes / 60);
      const m = totalMinutes % 60;
      if(h <= 0) return `${m} min`;
      return `${h} h ${m.toString().padStart(2,'0')} min`;
    }

    function updateEstimate(){
      const spool = selectedSpool();
      if(!currentAnalysis || currentAnalysis.error){
        estimateBox.innerHTML = '<p class="hint">Carica un modello per abilitare la stima.</p>';
        return;
      }
      if(!spool){
        estimateBox.innerHTML = '<p class="hint">Seleziona un materiale dalla palette per calcolare peso, tempo e costi.</p>';
        return;
      }

      const volumeSolid = Math.max(currentAnalysis.volume_mm3 || 0, 0);
      const surfaceArea = Math.max(currentAnalysis.surface_area_mm2 || 0, 0);
      const filamentDiameter = Math.max(getInputNumber('filamentDiameter', 1.75), 0.5);
      const nozzle = Math.max(getInputNumber('nozzle', 0.4), 0.1);
      const layerHeight = Math.max(getInputNumber('layerHeight', 0.2), 0.02);
      const shellThickness = Math.max(getInputNumber('shellThickness', 1.2), 0);
      const infill = Math.min(Math.max(getInputNumber('infill', 15), 0), 100);
      const printSpeed = Math.max(getInputNumber('printSpeed', 60), 1);
      const timeMultiplier = Math.max(getInputNumber('timeMultiplier', 1.2), 1);

      const shellVolume = Math.min(volumeSolid, surfaceArea * shellThickness);
      const coreVolume = Math.max(volumeSolid - shellVolume, 0);
      const materialVolume = shellVolume + coreVolume * (infill / 100);

      const filamentArea = Math.PI * (filamentDiameter / 2) ** 2;
      const filamentLengthMm = materialVolume / filamentArea;
      const filamentLengthM = filamentLengthMm / 1000;

      const density = densityForMaterial(spool.material || '');
      const volumeCm3 = materialVolume / 1000;
      const weightG = volumeCm3 * density;
      const pricePerKg = spool.price_per_kg;
      const materialCost = pricePerKg!=null ? (weightG / 1000) * pricePerKg : NaN;

      const extrusionWidth = nozzle * 1.05;
      const volumetricSpeed = printSpeed * layerHeight * extrusionWidth; // mm^3 / s
      const timeSeconds = volumetricSpeed > 0 ? (materialVolume / volumetricSpeed) : NaN;
      const totalHours = Number.isFinite(timeSeconds) ? (timeSeconds * timeMultiplier) / 3600 : NaN;
      const machineCost = Number.isFinite(totalHours) ? totalHours * (hourlyRate || 0) : NaN;
      const totalCost = (Number.isFinite(materialCost) ? materialCost : 0) + (Number.isFinite(machineCost) ? machineCost : 0);

      estimateBox.innerHTML = `
        <div class="result">
          <div class="result-title">Volume materiale</div>
          <div class="result-value">${formatNumber(volumeCm3, 2, ' cm³')}</div>
          <div class="result-sub">Volume solido modello: ${formatNumber(volumeSolid/1000, 2, ' cm³')}</div>
        </div>
        <div class="result">
          <div class="result-title">Peso stimato</div>
          <div class="result-value">${formatNumber(weightG, 1, ' g')}</div>
          <div class="result-sub">Densità stimata ${density.toFixed(2)} g/cm³</div>
        </div>
        <div class="result">
          <div class="result-title">Lunghezza filamento</div>
          <div class="result-value">${formatNumber(filamentLengthM, 2, ' m')}</div>
          <div class="result-sub">Diametro ${filamentDiameter.toFixed(2)} mm</div>
        </div>
        <div class="result">
          <div class="result-title">Tempo stampa</div>
          <div class="result-value">${formatDuration(totalHours)}</div>
          <div class="result-sub">Velocità ${printSpeed.toFixed(0)} mm/s · fattore ${timeMultiplier.toFixed(2)}</div>
        </div>
        <div class="result">
          <div class="result-title">Costo materiale</div>
          <div class="result-value">${Number.isFinite(materialCost) ? formatCurrency(materialCost) : 'n/d'}</div>
          <div class="result-sub">Prezzo bobina: ${pricePerKg!=null ? `${pricePerKg.toFixed(2)} ${currency}/kg` : 'n/d'}</div>
        </div>
        <div class="result">
          <div class="result-title">Costo macchina</div>
          <div class="result-value">${Number.isFinite(machineCost) ? formatCurrency(machineCost) : 'n/d'}</div>
          <div class="result-sub">Tariffa oraria: ${hourlyRate!=null ? formatCurrency(hourlyRate) : 'n/d'}</div>
        </div>
        <div class="result">
          <div class="result-title">Totale stimato</div>
          <div class="result-value">${Number.isFinite(totalCost) ? formatCurrency(totalCost) : 'n/d'}</div>
          <div class="result-sub">Materiale + macchina</div>
        </div>
      `;
    }

    document.getElementById('btnUpload').onclick = uploadFile;
    document.getElementById('btnFetch').onclick  = fetchFromUrl;

    ['filamentDiameter','nozzle','layerHeight','shellThickness','infill','printSpeed','timeMultiplier'].forEach(id=>{
      const el = document.getElementById(id);
      el?.addEventListener('change', updateEstimate);
      el?.addEventListener('input', () => { if(el.type !== 'range') updateEstimate(); });
    });

    renderModelStats();
    renderSpoolInfo();
    updateEstimate();

    loadPalette();
    setInterval(loadPalette, REFRESH_MS);
  </script>
</body>
</html>
