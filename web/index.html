<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Magazzino Filamenti & Stima</title>
  <style>
    :root{--bg:#0f172a;--card:#1e293b;--muted:#94a3b8;--text:#e2e8f0;--ring:#334155;--accent:#38bdf8}
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue","Noto Sans",sans-serif}
    .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:18px}
    @media (max-width:1000px){.grid{grid-template-columns:1fr}}
    .card{background:var(--card);border-radius:16px;padding:18px;border:1px solid var(--ring)}
    h1{margin:0 0 12px;font-size:28px}
    h2{margin:0 0 12px;font-size:18px}
    /* Compact the palette slightly by reducing gaps and paddings. Lower the max height so more of the page is
       available for the estimate section. */
    .palette{display:flex;flex-direction:column;gap:6px;max-height:360px;overflow:auto;padding-right:6px}
    .pill{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:8px 10px;border-radius:14px;background:#0b1527;border:1px solid var(--ring);cursor:pointer;font-size:14px}
    .pill[aria-selected="true"]{outline:2px solid var(--accent)}
    .left{display:flex;align-items:center;gap:12px}
    .dot{width:18px;height:18px;border-radius:50%;border:1px solid rgba(255,255,255,.25)}
    .dot.transparent{
      background-image:
        linear-gradient(45deg,#999 25%,transparent 25%),
        linear-gradient(-45deg,#999 25%,transparent 25%),
        linear-gradient(45deg,transparent 75%,#999 75%),
        linear-gradient(-45deg,transparent 75%,#999 75%);
      background-size:8px 8px;
      background-position:0 0,0 4px,4px -4px,-4px 0;
      background-color:#fff;
    }
    .title{font-weight:700}
    .sub{font-size:12px;color:var(--muted)}
    .price{font-weight:800}
    .row{display:flex;gap:12px;align-items:center}
    input[type="file"],input[type="text"],select,button{border-radius:10px;border:1px solid var(--ring);background:#0b1527;color:var(--text);padding:10px 12px}
    button{cursor:pointer}
    .hint{color:var(--muted);font-size:13px}
    .viewer{height:460px;border-radius:16px;border:1px dashed var(--ring);display:flex;align-items:center;justify-content:center;color:var(--muted)}
    .viewer.drag{border-color:var(--accent); color:var(--accent)}
    .est{display:grid;grid-template-columns:repeat(6,minmax(120px,1fr));gap:10px;margin-top:10px}
    @media (max-width:1100px){.est{grid-template-columns:repeat(3,1fr)}}
    /* Increase the visibility of the estimate output by enlarging the font and adding spacing */
    .out{margin-top:16px;font-size:16px;line-height:1.4}
    .out b{color:#fff;font-size:18px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Magazzino Filamenti & Stima</h1>
    <p class="hint">Dati e prezzi da Spoolman (€/kg). Costo macchina fisso lato server. La stima usa CuraEngine.</p>

    <div class="grid">
      <div class="card">
        <h2>Palette (seleziona materiale)</h2>
        <div id="palette" class="palette" role="listbox" aria-label="Seleziona materiale e colore per la stima"></div>
        <p class="hint">Ogni voce: <b>Materiale</b> — <span class="sub">Nome colore</span> — <b>€/kg</b>. Aggiornamento ogni 60 s.</p>
      </div>

      <div class="card">
        <h2>Viewer 3D (STL/3MF/OBJ)</h2>
        <div id="viewer" class="viewer" aria-live="polite">Trascina qui un file o caricalo dal pulsante sotto.</div>
      </div>
    </div>

    <div class="card" style="margin-top:18px">
      <h2>File & Stima</h2>
      <div class="row" style="flex-wrap:wrap">
        <input id="file" type="file" accept=".stl,.obj,.3mf,.zip" />
        <button id="btnUpload">Carica</button>
        <input id="url" type="text" placeholder="https://www.thingiverse.com/thing:..." style="flex:1;min-width:260px" />
        <button id="btnFetch">Da URL</button>
      </div>

      <div class="est">
        <label>Layer
          <select id="layer_h">
            <option value="0.20">0.20 mm</option>
            <option value="0.16">0.16 mm</option>
            <option value="0.12">0.12 mm</option>
            <option value="0.28">0.28 mm</option>
          </select>
        </label>
        <label>Infill
          <select id="infill">
            <option value="15">15%</option>
            <option value="5">5%</option>
            <option value="20">20%</option>
            <option value="40">40%</option>
          </select>
        </label>
        <label>Nozzle
          <select id="nozzle">
            <option value="0.4">0.4 mm</option>
            <option value="0.6">0.6 mm</option>
            <option value="0.2">0.2 mm</option>
          </select>
        </label>
        <label>Print speed
          <select id="print_speed">
            <!-- Generic speeds -->
            <option value="40">40 mm/s</option>
            <option value="60" selected>60 mm/s</option>
            <option value="80">80 mm/s</option>
            <!-- Higher speeds for fast machines like Bambu X1C -->
            <option value="100">100 mm/s</option>
            <option value="160">160 mm/s</option>
            <option value="200">200 mm/s</option>
            <option value="250">250 mm/s</option>
          </select>
        </label>
        <label>Travel speed
          <select id="travel_speed">
            <!-- Generic speeds -->
            <option value="100">100 mm/s</option>
            <option value="150" selected>150 mm/s</option>
            <option value="200">200 mm/s</option>
            <!-- Higher speeds for fast machines -->
            <option value="300">300 mm/s</option>
            <option value="500">500 mm/s</option>
          </select>
        </label>
        <!-- Introduce a preset selector to quickly apply common profiles. Each preset sets
             layer height, infill percentage, nozzle diameter, print speed, travel speed
             and the target machine (generic FDM or Bambu X1C). Users can still tweak the
             values manually after choosing a preset. -->
        <label>Preset
          <select id="preset">
            <option value="">-- Personalizzato --</option>
            <optgroup label="Bambu X1C">
              <option value="x1c_standard_020">X1C 0.20 Standard</option>
              <option value="x1c_quality_016">X1C 0.16 Quality</option>
              <option value="x1c_fine_012">X1C 0.12 Fine</option>
              <option value="x1c_draft_028">X1C 0.28 Draft</option>
            </optgroup>
          </select>
        </label>
        <div style="display:flex;align-items:end">
          <button id="btnEstimate">Stima</button>
        </div>
      </div>

      <div id="out" class="out"></div>
    </div>
  </div>

  <script>
    // ---------- util colore ----------
    function hexToRgb(hex){
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex||"");
      return m ? {r:parseInt(m[1],16), g:parseInt(m[2],16), b:parseInt(m[3],16)} : {r:127,g:127,b:127};
    }
    const BASIC = {
      "#000000":"Nero", "#FFFFFF":"Bianco", "#FF0000":"Rosso", "#00FF00":"Verde",
      "#0000FF":"Blu", "#FFFF00":"Giallo", "#FFA500":"Arancione", "#FFC0CB":"Rosa",
      "#800080":"Viola", "#A52A2A":"Marrone", "#808080":"Grigio", "#00FFFF":"Ciano",
      "#008000":"Verde scuro", "#ADD8E6":"Azzurro", "#FFD700":"Oro", "#8B4513":"Terra di Siena"
    };
    function nearestBasicName(hex){
      const {r,g,b}=hexToRgb(hex), entries=Object.entries(BASIC);
      let best=entries[0][0], dist=1e9;
      for(const [h] of entries){
        const c=hexToRgb(h); const d=(r-c.r)**2+(g-c.g)**2+(b-c.b)**2;
        if(d<dist){dist=d;best=h}
      }
      return BASIC[best];
    }

    // ---------- stato ----------
let selectedKey = null;
let currentViewerUrl = null;
// Track which machine (generic or bambu_x1c) should be used when estimating
let selectedMachine = "generic";
// Hold the most recent inventory items fetched from the server.
// Each element includes keys such as `key`, `color`, `material`, `diameter_mm`, `price_per_kg` and `is_transparent`.
// This cache is used later to apply the selected filament colour to the 3D model
// and to lookup the current selection for estimating costs.
let inventoryItems = [];
    const REFRESH_MS = 60000; // 60 s

    // ---------- palette ----------
    async function loadPalette(){
      const res = await fetch('/inventory?nocache='+Date.now());
      const data = await res.json();
  // Cache the items globally so other functions (e.g. showViewer) can access details
  inventoryItems = Array.isArray(data.items) ? data.items : [];
      renderPalette(data.items || []);
    }

    // ---------- preset handling ----------
    // Predefined printing presets. Each preset defines the machine to use and
    // suggested values for layer height (mm), infill (%), nozzle (mm),
    // print speed (mm/s) and travel speed (mm/s). Users can further tweak
    // individual settings after selecting a preset.
    const PRESETS = {
      "": { machine: "generic" },
      // Bambu Lab X1C presets approximated from typical manufacturer defaults
      "x1c_standard_020": { machine: "bambu_x1c", layer_h: 0.20, infill: 15, nozzle: 0.4, print_speed: 200, travel_speed: 500 },
      "x1c_quality_016": { machine: "bambu_x1c", layer_h: 0.16, infill: 15, nozzle: 0.4, print_speed: 200, travel_speed: 500 },
      "x1c_fine_012":    { machine: "bambu_x1c", layer_h: 0.12, infill: 20, nozzle: 0.4, print_speed: 160, travel_speed: 500 },
      "x1c_draft_028":   { machine: "bambu_x1c", layer_h: 0.28, infill: 15, nozzle: 0.4, print_speed: 250, travel_speed: 500 }
    };

    function applyPreset(key){
      const preset = PRESETS[key] || PRESETS[""];
      // Update selected machine
      selectedMachine = preset.machine || "generic";
      // For each setting, if defined, update the corresponding select input
      if(preset.layer_h != null){ document.getElementById('layer_h').value = preset.layer_h.toFixed(2); }
      if(preset.infill != null){ document.getElementById('infill').value   = preset.infill.toString(); }
      if(preset.nozzle != null){ document.getElementById('nozzle').value   = preset.nozzle.toFixed(1); }
      if(preset.print_speed != null){ document.getElementById('print_speed').value = preset.print_speed.toString(); }
      if(preset.travel_speed != null){ document.getElementById('travel_speed').value = preset.travel_speed.toString(); }
    }

    function renderPalette(items){
      const box = document.getElementById('palette');
      box.innerHTML = '';
      items
        .sort((a,b)=> (a.material||'').localeCompare(b.material||'') || (a.color||'').localeCompare(b.color||'' ) )
        .forEach(it=>{
          const hex = (it.color || '#777777').toUpperCase();
          const price = (it.price_per_kg!=null) ? `${it.price_per_kg.toFixed(2)} ${it.currency}/kg` : 'n/d';
          const colorName = it.color_name || nearestBasicName(hex);

          const row = document.createElement('div');
          row.className='pill';
          row.setAttribute('role','option');
          row.setAttribute('aria-label', `${it.material}, ${colorName}, ${price}`);
          row.setAttribute('aria-selected', selectedKey===it.key ? 'true' : 'false');
      row.onclick = () => {
        // Update the currently selected key and visual selection state
        selectedKey = it.key;
        [...box.children].forEach(c => c.setAttribute('aria-selected', 'false'));
        row.setAttribute('aria-selected', 'true');
        // If a model is already loaded in the viewer, reload it to apply the new colour.
        // The currentViewerUrl global holds the last loaded path and window.__lastModelName stores the original filename.
        if (currentViewerUrl) {
          // Use a brief timeout to allow the selection UI to update before re-rendering
          setTimeout(() => {
            showViewer(currentViewerUrl, window.__lastModelName || null);
          }, 0);
        }
      };

          const left = document.createElement('div'); left.className='left';
          const dot = document.createElement('span'); dot.className='dot' + (it.is_transparent ? ' transparent' : '');
          if(!it.is_transparent){ dot.style.backgroundColor = hex; }
          // Show only the human-friendly name in the tooltip (no HEX value)
          dot.title = colorName;
          dot.setAttribute('aria-hidden','true');

          const col = document.createElement('div');
          const t1 = document.createElement('div'); t1.className='title'; t1.textContent = it.material || 'n/d';
          const t2 = document.createElement('div'); t2.className='sub';
          // Display only the color name without its hex code in the palette
          t2.textContent = colorName;
          col.appendChild(t1); col.appendChild(t2);

          left.appendChild(dot); left.appendChild(col);
          const priceEl = document.createElement('div'); priceEl.className='price'; priceEl.textContent = price;

          row.appendChild(left); row.appendChild(priceEl);
          box.appendChild(row);
        });
    }

    // ---------- upload / fetch ----------
    async function uploadFileOrBlob(file){
      const fd = new FormData(); fd.append('file', file);
      const r = await fetch('/upload_model', {method:'POST', body: fd});
      if(!r.ok){ alert('Upload fallito'); return; }
      const j = await r.json();
      showViewer(j.viewer_url, j.filename);
    }

    async function uploadFile(){
      const f = document.getElementById('file').files[0];
      if(!f){ alert('Seleziona un file'); return; }
      uploadFileOrBlob(f);
    }

    async function fetchFromUrl(){
      const url = document.getElementById('url').value.trim();
      if(!url){ alert('Inserisci una URL'); return; }
      const r = await fetch('/fetch_model', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({url})});
      const j = await r.json();
      if(j.viewer_url){ showViewer(j.viewer_url, j.filename); } else { alert('Nessun modello trovato'); }
    }

    // drag & drop
    const viewer = document.getElementById('viewer');
    viewer.addEventListener('dragover', e => { e.preventDefault(); viewer.classList.add('drag'); });
    viewer.addEventListener('dragleave', () => viewer.classList.remove('drag'));
    viewer.addEventListener('drop', e => {
      e.preventDefault(); viewer.classList.remove('drag');
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if(f){ uploadFileOrBlob(f); }
    });

    /**
     * Render a 3D model in the viewer area. Supported formats are STL, OBJ and 3MF.
     * For unsupported extensions the link to the file is shown instead.
     *
     * This function dynamically imports Three.js and the required loaders on first
     * invocation. Subsequent calls reuse the cached modules to avoid
     * additional network requests.
     */
    async function showViewer(path, name){
      currentViewerUrl = path;
      // Store the last loaded filename globally so that switching filament colours can reload the model
      window.__lastModelName = name;
      const viewer = document.getElementById('viewer');
      // Remove any previous content and reset drag styling
      viewer.innerHTML = '';
      viewer.classList.remove('drag');


      // Only load the modules once; store them on window.__threeModules
      if(!window.__threeModules){
        window.__threeModules = {};
        try {
          window.__threeModules.THREE = await import('https://unpkg.com/three@0.147.0/build/three.module.js?module');
          window.__threeModules.OrbitControls = (await import('https://unpkg.com/three@0.147.0/examples/jsm/controls/OrbitControls.js?module')).OrbitControls;
          window.__threeModules.STLLoader = (await import('https://unpkg.com/three@0.147.0/examples/jsm/loaders/STLLoader.js?module')).STLLoader;
          window.__threeModules.OBJLoader = (await import('https://unpkg.com/three@0.147.0/examples/jsm/loaders/OBJLoader.js?module')).OBJLoader;
          window.__threeModules.ThreeMFLoader = (await import('https://unpkg.com/three@0.147.0/examples/jsm/loaders/3MFLoader.js?module')).ThreeMFLoader;
        } catch(err){
          console.error('Errore nel caricamento delle librerie Three.js:', err);
        }
      }

      const { THREE, OrbitControls, STLLoader, OBJLoader, ThreeMFLoader } = window.__threeModules;
      if(!THREE){
        // If modules failed to load, fall back to showing the link
        viewer.innerHTML = `<a href="${path}" target="_blank" style="color:var(--accent)">${path}</a>`;
        document.getElementById('out').innerHTML = '';
        return;
      }

      // Determine which loader to use based on file extension
      const extMatch = path.split('.').pop().toLowerCase().split('?')[0];
      let loader;
      if(extMatch === 'stl') loader = new STLLoader();
      else if(extMatch === 'obj') loader = new OBJLoader();
      else if(extMatch === '3mf') loader = new ThreeMFLoader();
      else {
        // Unsupported extension: show a link instead of 3D preview
        viewer.innerHTML = `<a href="${path}" target="_blank" style="color:var(--accent)">${path}</a>`;
        document.getElementById('out').innerHTML = '';
        return;
      }

      // Create renderer, scene, camera and controls
      const width = viewer.clientWidth;
      const height = viewer.clientHeight;
      const canvas = document.createElement('div');
      canvas.style.width = '100%';
      canvas.style.height = height + 'px';
      viewer.appendChild(canvas);

      const scene = new THREE.Scene();
      // Use the page's background variable for the scene background
      const bg = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim() || '#0f172a';
      scene.background = new THREE.Color(bg);
      const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(width, height);
      canvas.appendChild(renderer.domElement);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.1;

      // Lighting
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);
      const directional = new THREE.DirectionalLight(0xffffff, 0.8);
      directional.position.set(3, 10, 5);
      scene.add(directional);

      // Load the model
      loader.load(path, (result) => {
        let object;
        // Determine the selected spool details to apply colour and transparency
        const sel = inventoryItems.find(x => x.key === selectedKey) || {};
        let hex = sel.color || '#aaaaaa';
        // Ensure hex starts with '#'
        if(!hex.startsWith('#')) hex = '#' + hex;
        const col = new THREE.Color(hex);
        const isTransp = Boolean(sel.is_transparent);
        // For STL, result is a geometry; wrap it in a Mesh with custom material
        if(extMatch === 'stl'){
          const material = new THREE.MeshStandardMaterial({
            color: col,
            transparent: isTransp,
            opacity: isTransp ? 0.6 : 1.0,
            metalness: 0.1,
            roughness: 0.8
          });
          object = new THREE.Mesh(result, material);
        } else {
          object = result;
          // Traverse all child meshes and update their material colour
          object.traverse((child) => {
            if(child.isMesh){
              // If the mesh has a material, clone it to avoid affecting shared materials
              let mat = child.material;
              if(Array.isArray(mat)){
                mat = mat.map(m => m.clone());
              } else if(mat){
                mat = mat.clone();
              }
              // Set colour and transparency
              if(mat){
                if(Array.isArray(mat)){
                  mat.forEach(m => {
                    m.color = col.clone();
                    m.transparent = isTransp;
                    m.opacity = isTransp ? 0.6 : 1.0;
                  });
                } else {
                  mat.color = col.clone();
                  mat.transparent = isTransp;
                  mat.opacity = isTransp ? 0.6 : 1.0;
                }
                child.material = mat;
              }
            }
          });
        }
        scene.add(object);
        // Center the object and adjust camera
        const box = new THREE.Box3().setFromObject(object);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        // Compute max dimension and set camera distance accordingly
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        let cameraZ = Math.abs(maxDim / (2 * Math.tan(fov / 2)));
        camera.position.set(center.x, center.y, center.z + cameraZ * 1.5);
        camera.near = maxDim / 100;
        camera.far = maxDim * 100;
        camera.updateProjectionMatrix();
        controls.target.copy(center);
        controls.update();
        // Animation loop
        (function animate(){
          requestAnimationFrame(animate);
          controls.update();
          renderer.render(scene, camera);
        })();
      }, undefined, (error) => {
        console.error('Errore nel caricamento del modello 3D:', error);
        viewer.innerHTML = `<a href="${path}" target="_blank" style="color:var(--accent)">${path}</a>`;
      });
      // Clear any previous output from the stima
      document.getElementById('out').innerHTML = '';
    }

    async function estimate(){
      if(!currentViewerUrl){ alert('Carica prima un modello'); return; }
      if(!selectedKey){ alert('Seleziona un materiale dalla palette'); return; }
      const payload = {
        viewer_url: currentViewerUrl,
        inventory_key: selectedKey,
        // Provide the selected machine at the top-level to inform the server which
        // printer profile to use (generic or bambu_x1c). See api/main.py for
        // details.
        machine: selectedMachine,
        settings: {
          machine: selectedMachine,
          layer_h: parseFloat(document.getElementById('layer_h').value),
          infill: parseFloat(document.getElementById('infill').value),
          nozzle: parseFloat(document.getElementById('nozzle').value),
          print_speed: parseFloat(document.getElementById('print_speed').value),
          travel_speed: parseFloat(document.getElementById('travel_speed').value)
        }
      };
      const r = await fetch('/slice/estimate', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
      const j = await r.json();
      if(!r.ok){ alert(j.detail || 'Errore stima'); return; }
      const tmin = Math.round(j.time_s/60);
      document.getElementById('out').innerHTML = `
        Tempo: <b>${tmin} min</b> — Filamento: <b>${j.filament_g} g</b><br>
        Costo filamento: <b>${j.cost_filament} ${j.currency}</b> — Costo macchina: <b>${j.cost_machine} ${j.currency}</b><br>
        Totale: <b>${j.total} ${j.currency}</b> — <a href="${j.gcode_url}" target="_blank" style="color:var(--accent)">Scarica G-code</a>
      `;
    }

    // ---------- init ----------
    document.getElementById('btnUpload').onclick = uploadFile;
    document.getElementById('btnFetch').onclick  = fetchFromUrl;
    document.getElementById('btnEstimate').onclick  = estimate;
    // When the preset selection changes, apply the selected preset
    const presetSel = document.getElementById('preset');
    if(presetSel){
      presetSel.onchange = () => applyPreset(presetSel.value);
    }
    loadPalette();
    setInterval(loadPalette, REFRESH_MS);
  </script>
</body>
</html>
