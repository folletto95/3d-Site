<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Magazzino Filamenti & Stima</title>
  <style>
    :root{--bg:#0f172a;--card:#1e293b;--muted:#94a3b8;--text:#e2e8f0;--ring:#334155;--accent:#38bdf8}
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue","Noto Sans",sans-serif}
    .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:18px}
    @media (max-width:1000px){.grid{grid-template-columns:1fr}}
    .card{background:var(--card);border-radius:16px;padding:18px;border:1px solid var(--ring)}
    h1{margin:0 0 12px;font-size:28px}
    h2{margin:0 0 12px;font-size:18px}
    .palette{display:flex;flex-direction:column;gap:10px;max-height:460px;overflow:auto;padding-right:6px}
    .pill{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px 14px;border-radius:16px;background:#0b1527;border:1px solid var(--ring);cursor:pointer}
    .pill[aria-selected="true"]{outline:2px solid var(--accent)}
    .left{display:flex;align-items:center;gap:12px}
    .dot{width:18px;height:18px;border-radius:50%;border:1px solid rgba(255,255,255,.25)}
    .dot.transparent{
      background-image:
        linear-gradient(45deg,#999 25%,transparent 25%),
        linear-gradient(-45deg,#999 25%,transparent 25%),
        linear-gradient(45deg,transparent 75%,#999 75%),
        linear-gradient(-45deg,transparent 75%,#999 75%);
      background-size:8px 8px;
      background-position:0 0,0 4px,4px -4px,-4px 0;
      background-color:#fff;
    }
    .title{font-weight:700}
    .sub{font-size:12px;color:var(--muted)}
    .price{font-weight:800}
    .row{display:flex;gap:12px;align-items:center}
    input[type="file"],input[type="text"],input[type="number"],select,button{border-radius:10px;border:1px solid var(--ring);background:#0b1527;color:var(--text);padding:10px 12px}
    button{cursor:pointer}
    .process-grid input,.process-grid select,#finishSelect{width:100%}
    .hint{color:var(--muted);font-size:13px}
    .viewer{height:460px;border-radius:16px;border:1px dashed var(--ring);display:flex;align-items:center;justify-content:center;color:var(--muted)}
    .viewer.drag{border-color:var(--accent); color:var(--accent)}
    .out{margin-top:12px;font-size:14px}
    .out b{color:#fff}
    @media (max-width:640px){.row{flex-direction:column;align-items:stretch}}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Magazzino Filamenti & Stima</h1>
    <p class="hint">Dati e prezzi da Spoolman (€/kg). Costo macchina fisso lato server. La stima usa CuraEngine.</p>

    <div class="grid">
      <div class="card">
        <h2>Palette (seleziona materiale)</h2>
        <div id="palette" class="palette" role="listbox" aria-label="Seleziona materiale e colore per la stima"></div>
        <p class="hint">Ogni voce: <b>Materiale</b> — <span class="sub">Nome colore</span> — <b>€/kg</b>. Aggiornamento ogni 60 s.</p>
      </div>

      <div class="card">
        <h2>Viewer 3D (STL/3MF/OBJ)</h2>
        <div id="viewer" class="viewer" aria-live="polite">Trascina qui un file o caricalo dal pulsante sotto.</div>
      </div>
    </div>

    <section class="card" style="margin-top:18px">
      <h3>Finitura</h3>
      <select id="finishSelect"></select>

      <div class="grid process-grid" style="margin-top:12px">
        <div>
          <label>Altezza strato (mm)</label>
          <input id="layer_height_mm" type="number" step="0.01" min="0.05" max="0.40">
        </div>
        <div id="perimeters_wrapper">
          <label>Pareti</label>
          <input id="perimeters" type="number" min="1" max="10">
        </div>
        <div id="top_bottom_layers">
          <label>Top layers</label>
          <input id="top_solid_layers" type="number" min="0" max="20">
          <label>Bottom layers</label>
          <input id="bottom_solid_layers" type="number" min="0" max="20">
        </div>
        <div id="infill">
          <label>Infill %</label>
          <input id="infill_density_percent" type="number" min="0" max="100">
          <label>Pattern</label>
          <select id="infill_pattern">
            <option value="gyroid">Gyroid</option>
            <option value="grid">Grid</option>
            <option value="lines">Lines</option>
            <option value="cubic">Cubic</option>
            <option value="none">None</option>
          </select>
          <label>Top/Bottom pattern</label>
          <select id="top_bottom_pattern">
            <option value="monotonic">Monotonic</option>
            <option value="rectilinear">Rectilinear</option>
            <option value="concentric">Concentric</option>
          </select>
        </div>
        <div>
          <label>Layer infill sparso (mm)</label>
          <input id="sparse_infill_layer_height_mm" type="number" step="0.01" min="0.05" max="1">
        </div>
        <div>
          <label>Seam</label>
          <select id="seam_position">
            <option value="back">Posteriore</option>
            <option value="aligned">Allineata</option>
            <option value="random">Casuale</option>
          </select>
        </div>
        <div>
          <label>Ironing</label>
          <select id="ironing">
            <option value="off">Spento</option>
            <option value="topmost">Solo top più alto</option>
            <option value="all">Tutte le superfici top</option>
          </select>
        </div>
        <div>
          <label>Fuzzy skin</label>
          <select id="fuzzy_skin">
            <option value="off">No</option>
            <option value="on">Sì</option>
          </select>
        </div>
      </div>
    </section>

    <div class="card" style="margin-top:18px">
      <h2>File & Stima</h2>
      <div class="row" style="flex-wrap:wrap">
        <input id="file" type="file" accept=".stl,.obj,.3mf,.zip" />
        <button id="btnUpload">Carica</button>
        <input id="url" type="text" placeholder="https://www.thingiverse.com/thing:..." style="flex:1;min-width:260px" />
        <button id="btnFetch">Da URL</button>
      </div>

      <div class="row" style="margin-top:18px;justify-content:flex-end">
        <button id="btnEstimate">Calcola stima</button>
      </div>

      <div id="out" class="out"></div>
    </div>
  </div>

  <script type="module">
    import { PRINTING_PROFILES } from "./js/printingProfiles.js";

    // ---------- util colore ----------
    function hexToRgb(hex){
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex||"");
      return m ? {r:parseInt(m[1],16), g:parseInt(m[2],16), b:parseInt(m[3],16)} : {r:127,g:127,b:127};
    }
    const BASIC = {
      "#000000":"Nero", "#FFFFFF":"Bianco", "#FF0000":"Rosso", "#00FF00":"Verde",
      "#0000FF":"Blu", "#FFFF00":"Giallo", "#FFA500":"Arancione", "#FFC0CB":"Rosa",
      "#800080":"Viola", "#A52A2A":"Marrone", "#808080":"Grigio", "#00FFFF":"Ciano",
      "#008000":"Verde scuro", "#ADD8E6":"Azzurro", "#FFD700":"Oro", "#8B4513":"Terra di Siena"
    };
    function nearestBasicName(hex){
      const {r,g,b}=hexToRgb(hex), entries=Object.entries(BASIC);
      let best=entries[0][0], dist=1e9;
      for(const [h] of entries){
        const c=hexToRgb(h); const d=(r-c.r)**2+(g-c.g)**2+(b-c.b)**2;
        if(d<dist){dist=d;best=h}
      }
      return BASIC[best];
    }

    // ---------- stato ----------
    let selectedKey = null;
    let selectedSpool = null;
    let currentViewerUrl = null;
    let currentModelName = null;
    let inventoryItems = [];
    const REFRESH_MS = 60000; // 60 s

    const finishSel = document.getElementById("finishSelect");
    const fields = [
      "layer_height_mm","perimeters","top_solid_layers","bottom_solid_layers",
      "infill_density_percent","infill_pattern","top_bottom_pattern",
      "sparse_infill_layer_height_mm","spiral_vase","ironing","fuzzy_skin","seam_position"
    ];

    Object.entries(PRINTING_PROFILES).forEach(([id, profile], index)=>{
      const option = document.createElement("option");
      option.value = id;
      option.textContent = profile.label;
      finishSel.appendChild(option);
      if(index === 0){ finishSel.value = id; }
    });
    finishSel.addEventListener("change", () => applyFinish(finishSel.value));
    document.getElementById('infill_pattern').addEventListener('change', (event) => {
      if(event.target.value !== 'none'){
        lockUI(false);
      } else {
        const locks = PRINTING_PROFILES[finishSel.value]?.uiLocks || [];
        locks.forEach(lock => lockUI(lock, true));
      }
    });
    applyFinish(finishSel.value || Object.keys(PRINTING_PROFILES)[0]);

    function applyFinish(id){
      const prof = PRINTING_PROFILES[id];
      const set = prof?.set || {};
      fields.forEach(key => {
        const el = document.getElementById(key);
        if(!el || set[key] === undefined) return;
        if(typeof set[key] === "boolean"){
          el.value = set[key] ? "on" : "off";
        } else {
          el.value = set[key];
        }
      });
      lockUI(false);
      (prof?.uiLocks || []).forEach(lock => lockUI(lock, true));
    }

    function lockUI(section = false, lock = false){
      const byId = id => document.getElementById(id);
      const sections = {
        "infill": byId("infill"),
        "perimeters": byId("perimeters_wrapper"),
        "top_bottom_layers": byId("top_bottom_layers")
      };
      if(section === false){
        Object.values(sections).forEach(div => {
          if(!div) return;
          div.querySelectorAll("input,select").forEach(e=>{ e.disabled = false; });
          div.style.opacity = 1;
        });
        const per = byId("perimeters");
        if(per){ per.disabled = false; }
        return;
      }
      const target = sections[section];
      if(target){
        target.querySelectorAll("input,select").forEach(e=>{ e.disabled = lock; });
        target.style.opacity = lock ? 0.5 : 1;
      }
      if(section === "perimeters"){
        const per = byId("perimeters");
        if(per){ per.disabled = lock; }
      }
    }

    function setFieldValue(id, value){
      const el = document.getElementById(id);
      if(el){ el.value = value; }
    }

    window.getProcessConfig = () => {
      const q = id => document.getElementById(id)?.value;
      return {
        layer_height_mm: parseFloat(q("layer_height_mm")),
        perimeters: parseInt(q("perimeters"), 10),
        top_solid_layers: parseInt(q("top_solid_layers"), 10),
        bottom_solid_layers: parseInt(q("bottom_solid_layers"), 10),
        infill_density_percent: parseInt(q("infill_density_percent"), 10),
        infill_pattern: q("infill_pattern"),
        top_bottom_pattern: q("top_bottom_pattern"),
        sparse_infill_layer_height_mm: parseFloat(q("sparse_infill_layer_height_mm")||"0"),
        spiral_vase: q("infill_pattern") === "none",
        ironing: q("ironing"),
        fuzzy_skin: q("fuzzy_skin"),
        seam_position: q("seam_position")
      };
    };

    function normalizeProcess(proc){
      const normalized = {...proc};
      if(Number.isNaN(normalized.layer_height_mm)) normalized.layer_height_mm = 0.2;
      if(Number.isNaN(normalized.perimeters)) normalized.perimeters = 2;
      if(Number.isNaN(normalized.top_solid_layers)) normalized.top_solid_layers = 5;
      if(Number.isNaN(normalized.bottom_solid_layers)) normalized.bottom_solid_layers = 5;
      if(Number.isNaN(normalized.infill_density_percent)) normalized.infill_density_percent = 15;
      if(Number.isNaN(normalized.sparse_infill_layer_height_mm) || normalized.sparse_infill_layer_height_mm <= 0){
        normalized.sparse_infill_layer_height_mm = normalized.layer_height_mm * 2;
      }
      if(normalized.perimeters < 1){
        normalized.perimeters = 1;
        setFieldValue("perimeters", 1);
      }
      if(normalized.top_solid_layers < 0){
        normalized.top_solid_layers = 0;
        setFieldValue("top_solid_layers", 0);
      }
      if(normalized.bottom_solid_layers < 0){
        normalized.bottom_solid_layers = 0;
        setFieldValue("bottom_solid_layers", 0);
      }
      if(normalized.infill_density_percent < 0){
        normalized.infill_density_percent = 0;
        setFieldValue("infill_density_percent", 0);
      }
      if(normalized.infill_density_percent > 100){
        normalized.infill_density_percent = 100;
        setFieldValue("infill_density_percent", 100);
      }
      
      if(normalized.spiral_vase){
        normalized.perimeters = 1;
        normalized.top_solid_layers = 0;
        normalized.infill_density_percent = 0;
        setFieldValue("perimeters", 1);
        setFieldValue("top_solid_layers", 0);
        setFieldValue("infill_density_percent", 0);
        lockUI("infill", true);
        lockUI("top_bottom_layers", true);
        lockUI("perimeters", true);
      }

      if(normalized.layer_height_mm < 0.08 || normalized.layer_height_mm > 0.28){
        alert("Con ugello da 0.4 mm mantieni l'altezza strato tra 0.08 e 0.28 mm.");
        return null;
      }

      if(normalized.infill_density_percent === 0 && normalized.perimeters < 3 && !normalized.spiral_vase){
        alert("Con infill al 0% usa almeno 3 pareti per dare rigidità alle superfici.");
        return null;
      }

      return normalized;
    }

    function warnForMaterial(processCfg){
      if(!selectedSpool) return;
      const mat = (selectedSpool.material || "").toUpperCase();
      const needsHighTemp = ["PA", "PC", "ABS", "ASA"].some(tag => mat.includes(tag));
      if(needsHighTemp){
        alert("Materiale tecnico: usa piano High-Temp/Engineering e adesione aggressiva.");
      }
      if(mat.includes("TPU") && (processCfg.spiral_vase || processCfg.perimeters <= 1)){
        alert("TPU: evita modalità vaso con pareti troppo sottili per mantenere stabilità.");
      }
    }

    // ---------- palette ----------
    async function loadPalette(){
      const res = await fetch('/inventory?nocache='+Date.now());
      const data = await res.json();
      inventoryItems = Array.isArray(data.items) ? data.items : [];
      renderPalette(inventoryItems);
    }

    function renderPalette(items){
      const box = document.getElementById('palette');
      box.innerHTML = '';
      items
        .sort((a,b)=> (a.material||'').localeCompare(b.material||'') || (a.color||'').localeCompare(b.color||''))
        .forEach(it=>{
          const hex = (it.color || '#777777').toUpperCase();
          const price = (it.price_per_kg!=null) ? `${it.price_per_kg.toFixed(2)} ${it.currency}/kg` : 'n/d';
          const colorName = it.color_name || nearestBasicName(hex);

          const row = document.createElement('div');
          row.className='pill';
          row.setAttribute('role','option');
          row.setAttribute('aria-label', `${it.material}, ${colorName}, ${price}`);
          const isSelected = selectedKey===it.key;
          row.setAttribute('aria-selected', isSelected ? 'true' : 'false');
          if(isSelected){
            selectedSpool = it;
          }
          row.onclick = ()=>{
            selectedKey = it.key;
            selectedSpool = it;
            [...box.children].forEach(c=>c.setAttribute('aria-selected','false'));
            row.setAttribute('aria-selected','true');
          };

          const left = document.createElement('div'); left.className='left';
          const dot = document.createElement('span'); dot.className='dot' + (it.is_transparent ? ' transparent' : '');
          if(!it.is_transparent){ dot.style.backgroundColor = hex; }
          dot.title = colorName;
          dot.setAttribute('aria-hidden','true');

          const col = document.createElement('div');
          const t1 = document.createElement('div'); t1.className='title'; t1.textContent = it.material || 'n/d';
          const t2 = document.createElement('div'); t2.className='sub';
          t2.textContent = colorName;
          col.appendChild(t1); col.appendChild(t2);

          left.appendChild(dot); left.appendChild(col);
          const priceEl = document.createElement('div'); priceEl.className='price'; priceEl.textContent = price;

          row.appendChild(left); row.appendChild(priceEl);
          box.appendChild(row);
        });
    }

    // ---------- upload / fetch ----------
    async function uploadFileOrBlob(file){
      const fd = new FormData(); fd.append('file', file);
      const r = await fetch('/upload_model', {method:'POST', body: fd});
      if(!r.ok){ alert('Upload fallito'); return; }
      const j = await r.json();
      currentModelName = j.filename;
      showViewer(j.viewer_url, j.filename);
    }

    async function uploadFile(){
      const f = document.getElementById('file').files[0];
      if(!f){ alert('Seleziona un file'); return; }
      uploadFileOrBlob(f);
    }

    async function fetchFromUrl(){
      const url = document.getElementById('url').value.trim();
      if(!url){ alert('Inserisci una URL'); return; }
      const r = await fetch('/fetch_model', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({url})});
      const j = await r.json();
      if(j.viewer_url){
        currentModelName = j.filename;
        showViewer(j.viewer_url, j.filename);
      } else {
        alert('Nessun modello trovato');
      }
    }

    const viewer = document.getElementById('viewer');
    viewer.addEventListener('dragover', e => { e.preventDefault(); viewer.classList.add('drag'); });
    viewer.addEventListener('dragleave', () => viewer.classList.remove('drag'));
    viewer.addEventListener('drop', e => {
      e.preventDefault(); viewer.classList.remove('drag');
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if(f){ uploadFileOrBlob(f); }
    });

    async function showViewer(path, name){
      currentViewerUrl = path;
      currentModelName = name || currentModelName;
      const viewerEl = document.getElementById('viewer');
      viewerEl.innerHTML = '';
      viewerEl.classList.remove('drag');

      if(!window.__threeModules){
        window.__threeModules = {};
        try {
          window.__threeModules.THREE = await import('https://unpkg.com/three@0.147.0/build/three.module.js?module');
          window.__threeModules.OrbitControls = (await import('https://unpkg.com/three@0.147.0/examples/jsm/controls/OrbitControls.js?module')).OrbitControls;
          window.__threeModules.STLLoader = (await import('https://unpkg.com/three@0.147.0/examples/jsm/loaders/STLLoader.js?module')).STLLoader;
          window.__threeModules.OBJLoader = (await import('https://unpkg.com/three@0.147.0/examples/jsm/loaders/OBJLoader.js?module')).OBJLoader;
          window.__threeModules.ThreeMFLoader = (await import('https://unpkg.com/three@0.147.0/examples/jsm/loaders/3MFLoader.js?module')).ThreeMFLoader;
        } catch(err){
          console.error('Errore nel caricamento delle librerie Three.js:', err);
        }
      }

      const { THREE, OrbitControls, STLLoader, OBJLoader, ThreeMFLoader } = window.__threeModules;
      if(!THREE){
        viewerEl.innerHTML = `<a href="${path}" target="_blank" style="color:var(--accent)">${path}</a>`;
        document.getElementById('out').innerHTML = '';
        return;
      }

      const extMatch = path.split('.').pop().toLowerCase().split('?')[0];
      let loader;
      if(extMatch === 'stl') loader = new STLLoader();
      else if(extMatch === 'obj') loader = new OBJLoader();
      else if(extMatch === '3mf') loader = new ThreeMFLoader();
      else {
        viewerEl.innerHTML = `<a href="${path}" target="_blank" style="color:var(--accent)">${path}</a>`;
        document.getElementById('out').innerHTML = '';
        return;
      }

      const width = viewerEl.clientWidth;
      const height = viewerEl.clientHeight;
      const canvas = document.createElement('div');
      canvas.style.width = '100%';
      canvas.style.height = height + 'px';
      viewerEl.appendChild(canvas);

      const scene = new THREE.Scene();
      const bg = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim() || '#0f172a';
      scene.background = new THREE.Color(bg);
      const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(width, height);
      canvas.appendChild(renderer.domElement);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.1;

      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);
      const directional = new THREE.DirectionalLight(0xffffff, 0.8);
      directional.position.set(3, 10, 5);
      scene.add(directional);

      loader.load(path, (result) => {
        let object;
        const spool = selectedSpool || inventoryItems.find(x => x.key === selectedKey) || {};
        let hex = spool.color || '#aaaaaa';
        if(hex && !hex.startsWith('#')) hex = '#' + hex;
        const col = new THREE.Color(hex);
        const isTransp = Boolean(spool.is_transparent);
        if(extMatch === 'stl'){
          const material = new THREE.MeshStandardMaterial({
            color: col,
            transparent: isTransp,
            opacity: isTransp ? 0.6 : 1.0,
            metalness: 0.1,
            roughness: 0.8
          });
          object = new THREE.Mesh(result, material);
        } else {
          object = result;
          object.traverse((child) => {
            if(child.isMesh){
              let mat = child.material;
              if(Array.isArray(mat)){
                mat = mat.map(m => m.clone());
              } else if(mat){
                mat = mat.clone();
              }
              if(mat){
                if(Array.isArray(mat)){
                  mat.forEach(m => {
                    m.color = col.clone();
                    m.transparent = isTransp;
                    m.opacity = isTransp ? 0.6 : 1.0;
                  });
                } else {
                  mat.color = col.clone();
                  mat.transparent = isTransp;
                  mat.opacity = isTransp ? 0.6 : 1.0;
                }
                child.material = mat;
              }
            }
          });
        }
        scene.add(object);
        const box = new THREE.Box3().setFromObject(object);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        let cameraZ = Math.abs(maxDim / (2 * Math.tan(fov / 2)));
        camera.position.set(center.x, center.y, center.z + cameraZ * 1.5);
        camera.near = Math.max(maxDim / 100, 0.1);
        camera.far = Math.max(maxDim * 100, 1000);
        camera.updateProjectionMatrix();
        controls.target.copy(center);
        controls.update();
        (function animate(){
          requestAnimationFrame(animate);
          controls.update();
          renderer.render(scene, camera);
        })();
      }, undefined, (error) => {
        console.error('Errore nel caricamento del modello 3D:', error);
        viewerEl.innerHTML = `<a href="${path}" target="_blank" style="color:var(--accent)">${path}</a>`;
      });
      document.getElementById('out').innerHTML = '';
    }

    async function estimate(){
      if(!currentViewerUrl){ alert('Carica prima un modello'); return; }
      if(!selectedKey){ alert('Seleziona un materiale dalla palette'); return; }
      selectedSpool = inventoryItems.find(x => x.key === selectedKey) || selectedSpool;
      if(!selectedSpool){ alert('Materiale non valido, ricarica la palette.'); return; }

      const rawProcess = window.getProcessConfig();
      const process = normalizeProcess(rawProcess);
      if(!process){ return; }
      warnForMaterial(process);
      const spoolColor = selectedSpool.color ? (selectedSpool.color.startsWith('#') ? selectedSpool.color : `#${selectedSpool.color}`) : null;

      const payload = {
        model_source: {
          viewer_url: currentViewerUrl,
          filename: currentModelName
        },
        material: {
          id_spoolman: selectedSpool.id ?? selectedSpool.spool_id ?? null,
          name: selectedSpool.material,
          color_hex: spoolColor
        },
        nozzle_mm: 0.4,
        plate: 'textured_pei',
        process
      };

      const r = await fetch('/api/estimate', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
      const j = await r.json();
      if(!r.ok){ alert(j.detail || 'Errore stima'); return; }
      const tmin = Math.round(j.time_s/60);
      document.getElementById('out').innerHTML = `
        Tempo: <b>${tmin} min</b> — Filamento: <b>${j.filament_g} g</b><br>
        Costo filamento: <b>${j.cost_filament} ${j.currency}</b> — Costo macchina: <b>${j.cost_machine} ${j.currency}</b><br>
        Totale: <b>${j.total} ${j.currency}</b> — <a href="${j.gcode_url}" target="_blank" style="color:var(--accent)">Scarica G-code</a>
      `;
    }

    // ---------- init ----------
    document.getElementById('btnUpload').onclick = uploadFile;
    document.getElementById('btnFetch').onclick  = fetchFromUrl;
    document.getElementById('btnEstimate').onclick  = estimate;
    loadPalette();
    setInterval(loadPalette, REFRESH_MS);
  </script>
</body>
</html>
